import {
  ApolloLink,
  InvariantError,
  addTypenameToDocument,
  argumentsObjectFromField,
  assign,
  bundle_esm_default,
  bundle_esm_exports,
  bundle_esm_exports2,
  canUseWeakMap,
  createFragmentMap,
  equal,
  fromError,
  getDefaultValues,
  getDirectiveInfoFromField,
  getFragmentDefinitions,
  getFragmentQueryDocument,
  getMainDefinition,
  getOperationDefinition,
  getQueryDefinition,
  getStoreKeyName,
  init_bundle_esm,
  init_bundle_esm2,
  init_bundle_esm3,
  init_invariant_esm,
  invariant,
  isField,
  isIdValue,
  isInlineFragment,
  isJsonValue,
  isProduction,
  isTest,
  maybeDeepFreeze,
  mergeDeepArray,
  resultKeyNameFromField,
  shouldInclude,
  storeKeyNameFromField,
  toIdValue
} from "./chunk-L2ZVQ24K.js";
import {
  init_lib,
  lib_exports,
  require_blockString,
  require_visitor
} from "./chunk-NWTBEJYO.js";
import "./chunk-J2SQABZG.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// ../../node_modules/apollo-link-http/node_modules/tslib/tslib.es6.js
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "../../node_modules/apollo-link-http/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign4(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// ../../node_modules/apollo-link-http-common/node_modules/tslib/tslib.es6.js
var __assign2;
var init_tslib_es62 = __esm({
  "../../node_modules/apollo-link-http-common/node_modules/tslib/tslib.es6.js"() {
    __assign2 = function() {
      __assign2 = Object.assign || function __assign4(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
  }
});

// ../../node_modules/graphql/language/printer.mjs
function print(ast) {
  return (0, import_visitor.visit)(ast, {
    leave: printDocASTReducer
  });
}
function addDescription(cb) {
  return function(node) {
    return join([node.description, cb(node)], "\n");
  };
}
function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter(function(x) {
    return x;
  }).join(separator || "") : "";
}
function block(array) {
  return array && array.length !== 0 ? "{\n" + indent(join(array, "\n")) + "\n}" : "";
}
function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
}
function indent(maybeString) {
  return maybeString && "  " + maybeString.replace(/\n/g, "\n  ");
}
function isMultiline(string) {
  return string.indexOf("\n") !== -1;
}
function hasMultilineItems(maybeArray) {
  return maybeArray && maybeArray.some(isMultiline);
}
var import_visitor, import_blockString, printDocASTReducer;
var init_printer = __esm({
  "../../node_modules/graphql/language/printer.mjs"() {
    import_visitor = __toESM(require_visitor(), 1);
    import_blockString = __toESM(require_blockString(), 1);
    printDocASTReducer = {
      Name: function Name(node) {
        return node.value;
      },
      Variable: function Variable(node) {
        return "$" + node.name;
      },
      Document: function Document(node) {
        return join(node.definitions, "\n\n") + "\n";
      },
      OperationDefinition: function OperationDefinition(node) {
        var op = node.operation;
        var name = node.name;
        var varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
        var directives = join(node.directives, " ");
        var selectionSet = node.selectionSet;
        return !name && !directives && !varDefs && op === "query" ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], " ");
      },
      VariableDefinition: function VariableDefinition(_ref) {
        var variable = _ref.variable, type = _ref.type, defaultValue = _ref.defaultValue, directives = _ref.directives;
        return variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "));
      },
      SelectionSet: function SelectionSet(_ref2) {
        var selections = _ref2.selections;
        return block(selections);
      },
      Field: function Field(_ref3) {
        var alias = _ref3.alias, name = _ref3.name, args = _ref3.arguments, directives = _ref3.directives, selectionSet = _ref3.selectionSet;
        return join([wrap("", alias, ": ") + name + wrap("(", join(args, ", "), ")"), join(directives, " "), selectionSet], " ");
      },
      Argument: function Argument(_ref4) {
        var name = _ref4.name, value = _ref4.value;
        return name + ": " + value;
      },
      FragmentSpread: function FragmentSpread(_ref5) {
        var name = _ref5.name, directives = _ref5.directives;
        return "..." + name + wrap(" ", join(directives, " "));
      },
      InlineFragment: function InlineFragment(_ref6) {
        var typeCondition = _ref6.typeCondition, directives = _ref6.directives, selectionSet = _ref6.selectionSet;
        return join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ");
      },
      FragmentDefinition: function FragmentDefinition(_ref7) {
        var name = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives = _ref7.directives, selectionSet = _ref7.selectionSet;
        return "fragment ".concat(name).concat(wrap("(", join(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap("", join(directives, " "), " ")) + selectionSet;
      },
      IntValue: function IntValue(_ref8) {
        var value = _ref8.value;
        return value;
      },
      FloatValue: function FloatValue(_ref9) {
        var value = _ref9.value;
        return value;
      },
      StringValue: function StringValue(_ref10, key) {
        var value = _ref10.value, isBlockString = _ref10.block;
        return isBlockString ? (0, import_blockString.printBlockString)(value, key === "description" ? "" : "  ") : JSON.stringify(value);
      },
      BooleanValue: function BooleanValue(_ref11) {
        var value = _ref11.value;
        return value ? "true" : "false";
      },
      NullValue: function NullValue() {
        return "null";
      },
      EnumValue: function EnumValue(_ref12) {
        var value = _ref12.value;
        return value;
      },
      ListValue: function ListValue(_ref13) {
        var values = _ref13.values;
        return "[" + join(values, ", ") + "]";
      },
      ObjectValue: function ObjectValue(_ref14) {
        var fields = _ref14.fields;
        return "{" + join(fields, ", ") + "}";
      },
      ObjectField: function ObjectField(_ref15) {
        var name = _ref15.name, value = _ref15.value;
        return name + ": " + value;
      },
      Directive: function Directive(_ref16) {
        var name = _ref16.name, args = _ref16.arguments;
        return "@" + name + wrap("(", join(args, ", "), ")");
      },
      NamedType: function NamedType(_ref17) {
        var name = _ref17.name;
        return name;
      },
      ListType: function ListType(_ref18) {
        var type = _ref18.type;
        return "[" + type + "]";
      },
      NonNullType: function NonNullType(_ref19) {
        var type = _ref19.type;
        return type + "!";
      },
      SchemaDefinition: function SchemaDefinition(_ref20) {
        var directives = _ref20.directives, operationTypes = _ref20.operationTypes;
        return join(["schema", join(directives, " "), block(operationTypes)], " ");
      },
      OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
        var operation = _ref21.operation, type = _ref21.type;
        return operation + ": " + type;
      },
      ScalarTypeDefinition: addDescription(function(_ref22) {
        var name = _ref22.name, directives = _ref22.directives;
        return join(["scalar", name, join(directives, " ")], " ");
      }),
      ObjectTypeDefinition: addDescription(function(_ref23) {
        var name = _ref23.name, interfaces = _ref23.interfaces, directives = _ref23.directives, fields = _ref23.fields;
        return join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      }),
      FieldDefinition: addDescription(function(_ref24) {
        var name = _ref24.name, args = _ref24.arguments, type = _ref24.type, directives = _ref24.directives;
        return name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "));
      }),
      InputValueDefinition: addDescription(function(_ref25) {
        var name = _ref25.name, type = _ref25.type, defaultValue = _ref25.defaultValue, directives = _ref25.directives;
        return join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ");
      }),
      InterfaceTypeDefinition: addDescription(function(_ref26) {
        var name = _ref26.name, directives = _ref26.directives, fields = _ref26.fields;
        return join(["interface", name, join(directives, " "), block(fields)], " ");
      }),
      UnionTypeDefinition: addDescription(function(_ref27) {
        var name = _ref27.name, directives = _ref27.directives, types = _ref27.types;
        return join(["union", name, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
      }),
      EnumTypeDefinition: addDescription(function(_ref28) {
        var name = _ref28.name, directives = _ref28.directives, values = _ref28.values;
        return join(["enum", name, join(directives, " "), block(values)], " ");
      }),
      EnumValueDefinition: addDescription(function(_ref29) {
        var name = _ref29.name, directives = _ref29.directives;
        return join([name, join(directives, " ")], " ");
      }),
      InputObjectTypeDefinition: addDescription(function(_ref30) {
        var name = _ref30.name, directives = _ref30.directives, fields = _ref30.fields;
        return join(["input", name, join(directives, " "), block(fields)], " ");
      }),
      DirectiveDefinition: addDescription(function(_ref31) {
        var name = _ref31.name, args = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
        return "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ");
      }),
      SchemaExtension: function SchemaExtension(_ref32) {
        var directives = _ref32.directives, operationTypes = _ref32.operationTypes;
        return join(["extend schema", join(directives, " "), block(operationTypes)], " ");
      },
      ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
        var name = _ref33.name, directives = _ref33.directives;
        return join(["extend scalar", name, join(directives, " ")], " ");
      },
      ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
        var name = _ref34.name, interfaces = _ref34.interfaces, directives = _ref34.directives, fields = _ref34.fields;
        return join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
      },
      InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
        var name = _ref35.name, directives = _ref35.directives, fields = _ref35.fields;
        return join(["extend interface", name, join(directives, " "), block(fields)], " ");
      },
      UnionTypeExtension: function UnionTypeExtension(_ref36) {
        var name = _ref36.name, directives = _ref36.directives, types = _ref36.types;
        return join(["extend union", name, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
      },
      EnumTypeExtension: function EnumTypeExtension(_ref37) {
        var name = _ref37.name, directives = _ref37.directives, values = _ref37.values;
        return join(["extend enum", name, join(directives, " "), block(values)], " ");
      },
      InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
        var name = _ref38.name, directives = _ref38.directives, fields = _ref38.fields;
        return join(["extend input", name, join(directives, " "), block(fields)], " ");
      }
    };
  }
});

// ../../node_modules/apollo-link-http-common/lib/bundle.esm.js
var defaultHttpOptions, defaultHeaders, defaultOptions, fallbackHttpConfig, throwServerError, parseAndCheckHttpResponse, checkFetcher, createSignalIfSupported, selectHttpOptionsAndBody, serializeFetchParameter, selectURI;
var init_bundle_esm4 = __esm({
  "../../node_modules/apollo-link-http-common/lib/bundle.esm.js"() {
    init_tslib_es62();
    init_printer();
    init_invariant_esm();
    defaultHttpOptions = {
      includeQuery: true,
      includeExtensions: false
    };
    defaultHeaders = {
      accept: "*/*",
      "content-type": "application/json"
    };
    defaultOptions = {
      method: "POST"
    };
    fallbackHttpConfig = {
      http: defaultHttpOptions,
      headers: defaultHeaders,
      options: defaultOptions
    };
    throwServerError = function(response, result, message) {
      var error = new Error(message);
      error.name = "ServerError";
      error.response = response;
      error.statusCode = response.status;
      error.result = result;
      throw error;
    };
    parseAndCheckHttpResponse = function(operations) {
      return function(response) {
        return response.text().then(function(bodyText) {
          try {
            return JSON.parse(bodyText);
          } catch (err) {
            var parseError = err;
            parseError.name = "ServerParseError";
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            return Promise.reject(parseError);
          }
        }).then(function(result) {
          if (response.status >= 300) {
            throwServerError(response, result, "Response not successful: Received status code " + response.status);
          }
          if (!Array.isArray(result) && !result.hasOwnProperty("data") && !result.hasOwnProperty("errors")) {
            throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations) ? operations.map(function(op) {
              return op.operationName;
            }) : operations.operationName) + "'.");
          }
          return result;
        });
      };
    };
    checkFetcher = function(fetcher) {
      if (!fetcher && typeof fetch === "undefined") {
        var library = "unfetch";
        if (typeof window === "undefined")
          library = "node-fetch";
        throw false ? new InvariantError(1) : new InvariantError("\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/" + library + ".\n\nFor example:\nimport fetch from '" + library + "';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });");
      }
    };
    createSignalIfSupported = function() {
      if (typeof AbortController === "undefined")
        return { controller: false, signal: false };
      var controller = new AbortController();
      var signal = controller.signal;
      return { controller, signal };
    };
    selectHttpOptionsAndBody = function(operation, fallbackConfig) {
      var configs = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        configs[_i - 2] = arguments[_i];
      }
      var options = __assign2({}, fallbackConfig.options, { headers: fallbackConfig.headers, credentials: fallbackConfig.credentials });
      var http = fallbackConfig.http;
      configs.forEach(function(config) {
        options = __assign2({}, options, config.options, { headers: __assign2({}, options.headers, config.headers) });
        if (config.credentials)
          options.credentials = config.credentials;
        http = __assign2({}, http, config.http);
      });
      var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
      var body = { operationName, variables };
      if (http.includeExtensions)
        body.extensions = extensions;
      if (http.includeQuery)
        body.query = print(query);
      return {
        options,
        body
      };
    };
    serializeFetchParameter = function(p, label) {
      var serialized;
      try {
        serialized = JSON.stringify(p);
      } catch (e) {
        var parseError = false ? new InvariantError(2) : new InvariantError("Network request failed. " + label + " is not serializable: " + e.message);
        parseError.parseError = e;
        throw parseError;
      }
      return serialized;
    };
    selectURI = function(operation, fallbackURI) {
      var context = operation.getContext();
      var contextURI = context.uri;
      if (contextURI) {
        return contextURI;
      } else if (typeof fallbackURI === "function") {
        return fallbackURI(operation);
      } else {
        return fallbackURI || "/graphql";
      }
    };
  }
});

// ../../node_modules/apollo-link-http/lib/bundle.esm.js
var bundle_esm_exports3 = {};
__export(bundle_esm_exports3, {
  HttpLink: () => HttpLink,
  createHttpLink: () => createHttpLink
});
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push(key + "=" + encodeURIComponent(value));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}
var createHttpLink, HttpLink;
var init_bundle_esm5 = __esm({
  "../../node_modules/apollo-link-http/lib/bundle.esm.js"() {
    init_tslib_es6();
    init_bundle_esm2();
    init_bundle_esm4();
    createHttpLink = function(linkOptions) {
      if (linkOptions === void 0) {
        linkOptions = {};
      }
      var _a = linkOptions.uri, uri = _a === void 0 ? "/graphql" : _a, fetcher = linkOptions.fetch, includeExtensions = linkOptions.includeExtensions, useGETForQueries = linkOptions.useGETForQueries, requestOptions = __rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries"]);
      checkFetcher(fetcher);
      if (!fetcher) {
        fetcher = fetch;
      }
      var linkConfig = {
        http: { includeExtensions },
        options: requestOptions.fetchOptions,
        credentials: requestOptions.credentials,
        headers: requestOptions.headers
      };
      return new ApolloLink(function(operation) {
        var chosenURI = selectURI(operation, uri);
        var context = operation.getContext();
        var clientAwarenessHeaders = {};
        if (context.clientAwareness) {
          var _a2 = context.clientAwareness, name_1 = _a2.name, version = _a2.version;
          if (name_1) {
            clientAwarenessHeaders["apollographql-client-name"] = name_1;
          }
          if (version) {
            clientAwarenessHeaders["apollographql-client-version"] = version;
          }
        }
        var contextHeaders = __assign({}, clientAwarenessHeaders, context.headers);
        var contextConfig = {
          http: context.http,
          options: context.fetchOptions,
          credentials: context.credentials,
          headers: contextHeaders
        };
        var _b = selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;
        var controller;
        if (!options.signal) {
          var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;
          controller = _controller;
          if (controller)
            options.signal = signal;
        }
        var definitionIsMutation = function(d) {
          return d.kind === "OperationDefinition" && d.operation === "mutation";
        };
        if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
          options.method = "GET";
        }
        if (options.method === "GET") {
          var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
          if (parseError) {
            return fromError(parseError);
          }
          chosenURI = newURI;
        } else {
          try {
            options.body = serializeFetchParameter(body, "Payload");
          } catch (parseError2) {
            return fromError(parseError2);
          }
        }
        return new bundle_esm_default(function(observer) {
          fetcher(chosenURI, options).then(function(response) {
            operation.setContext({ response });
            return response;
          }).then(parseAndCheckHttpResponse(operation)).then(function(result) {
            observer.next(result);
            observer.complete();
            return result;
          }).catch(function(err) {
            if (err.name === "AbortError")
              return;
            if (err.result && err.result.errors && err.result.data) {
              observer.next(err.result);
            }
            observer.error(err);
          });
          return function() {
            if (controller)
              controller.abort();
          };
        });
      });
    };
    HttpLink = function(_super) {
      __extends(HttpLink2, _super);
      function HttpLink2(opts) {
        return _super.call(this, createHttpLink(opts).request) || this;
      }
      return HttpLink2;
    }(ApolloLink);
  }
});

// ../../node_modules/apollo-cache-inmemory/node_modules/tslib/tslib.es6.js
function __extends2(d, b) {
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var extendStatics2, __assign3;
var init_tslib_es63 = __esm({
  "../../node_modules/apollo-cache-inmemory/node_modules/tslib/tslib.es6.js"() {
    extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    __assign3 = function() {
      __assign3 = Object.assign || function __assign4(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign3.apply(this, arguments);
    };
  }
});

// ../../node_modules/apollo-cache/lib/bundle.esm.js
function queryFromPojo(obj) {
  var op = {
    kind: "OperationDefinition",
    operation: "query",
    name: {
      kind: "Name",
      value: "GeneratedClientQuery"
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: "Document",
    definitions: [op]
  };
  return out;
}
function fragmentFromPojo(obj, typename) {
  var frag = {
    kind: "FragmentDefinition",
    typeCondition: {
      kind: "NamedType",
      name: {
        kind: "Name",
        value: typename || "__FakeType"
      }
    },
    name: {
      kind: "Name",
      value: "GeneratedClientQuery"
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: "Document",
    definitions: [frag]
  };
  return out;
}
function selectionSetFromObj(obj) {
  if (typeof obj === "number" || typeof obj === "boolean" || typeof obj === "string" || typeof obj === "undefined" || obj === null) {
    return null;
  }
  if (Array.isArray(obj)) {
    return selectionSetFromObj(obj[0]);
  }
  var selections = [];
  Object.keys(obj).forEach(function(key) {
    var nestedSelSet = selectionSetFromObj(obj[key]);
    var field = {
      kind: "Field",
      name: {
        kind: "Name",
        value: key
      },
      selectionSet: nestedSelSet || void 0
    };
    selections.push(field);
  });
  var selectionSet = {
    kind: "SelectionSet",
    selections
  };
  return selectionSet;
}
var justTypenameQuery, ApolloCache, Cache;
var init_bundle_esm6 = __esm({
  "../../node_modules/apollo-cache/lib/bundle.esm.js"() {
    init_bundle_esm();
    justTypenameQuery = {
      kind: "Document",
      definitions: [
        {
          kind: "OperationDefinition",
          operation: "query",
          name: null,
          variableDefinitions: null,
          directives: [],
          selectionSet: {
            kind: "SelectionSet",
            selections: [
              {
                kind: "Field",
                alias: null,
                name: {
                  kind: "Name",
                  value: "__typename"
                },
                arguments: [],
                directives: [],
                selectionSet: null
              }
            ]
          }
        }
      ]
    };
    ApolloCache = function() {
      function ApolloCache2() {
      }
      ApolloCache2.prototype.transformDocument = function(document) {
        return document;
      };
      ApolloCache2.prototype.transformForLink = function(document) {
        return document;
      };
      ApolloCache2.prototype.readQuery = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.read({
          query: options.query,
          variables: options.variables,
          optimistic
        });
      };
      ApolloCache2.prototype.readFragment = function(options, optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return this.read({
          query: getFragmentQueryDocument(options.fragment, options.fragmentName),
          variables: options.variables,
          rootId: options.id,
          optimistic
        });
      };
      ApolloCache2.prototype.writeQuery = function(options) {
        this.write({
          dataId: "ROOT_QUERY",
          result: options.data,
          query: options.query,
          variables: options.variables
        });
      };
      ApolloCache2.prototype.writeFragment = function(options) {
        this.write({
          dataId: options.id,
          result: options.data,
          variables: options.variables,
          query: getFragmentQueryDocument(options.fragment, options.fragmentName)
        });
      };
      ApolloCache2.prototype.writeData = function(_a) {
        var id = _a.id, data = _a.data;
        if (typeof id !== "undefined") {
          var typenameResult = null;
          try {
            typenameResult = this.read({
              rootId: id,
              optimistic: false,
              query: justTypenameQuery
            });
          } catch (e) {
          }
          var __typename = typenameResult && typenameResult.__typename || "__ClientData";
          var dataToWrite = Object.assign({ __typename }, data);
          this.writeFragment({
            id,
            fragment: fragmentFromPojo(dataToWrite, __typename),
            data: dataToWrite
          });
        } else {
          this.writeQuery({ query: queryFromPojo(data), data });
        }
      };
      return ApolloCache2;
    }();
    (function(Cache3) {
    })(Cache || (Cache = {}));
  }
});

// ../../node_modules/@wry/context/lib/context.esm.js
var currentContext, MISSING_VALUE, idCounter, makeSlotClass, globalKey, host, Slot, bind, noContext;
var init_context_esm = __esm({
  "../../node_modules/@wry/context/lib/context.esm.js"() {
    currentContext = null;
    MISSING_VALUE = {};
    idCounter = 1;
    makeSlotClass = function() {
      return function() {
        function Slot2() {
          this.id = [
            "slot",
            idCounter++,
            Date.now(),
            Math.random().toString(36).slice(2)
          ].join(":");
        }
        Slot2.prototype.hasValue = function() {
          for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
            if (this.id in context_1.slots) {
              var value = context_1.slots[this.id];
              if (value === MISSING_VALUE)
                break;
              if (context_1 !== currentContext) {
                currentContext.slots[this.id] = value;
              }
              return true;
            }
          }
          if (currentContext) {
            currentContext.slots[this.id] = MISSING_VALUE;
          }
          return false;
        };
        Slot2.prototype.getValue = function() {
          if (this.hasValue()) {
            return currentContext.slots[this.id];
          }
        };
        Slot2.prototype.withValue = function(value, callback, args, thisArg) {
          var _a;
          var slots = (_a = {
            __proto__: null
          }, _a[this.id] = value, _a);
          var parent = currentContext;
          currentContext = { parent, slots };
          try {
            return callback.apply(thisArg, args);
          } finally {
            currentContext = parent;
          }
        };
        Slot2.bind = function(callback) {
          var context = currentContext;
          return function() {
            var saved = currentContext;
            try {
              currentContext = context;
              return callback.apply(this, arguments);
            } finally {
              currentContext = saved;
            }
          };
        };
        Slot2.noContext = function(callback, args, thisArg) {
          if (currentContext) {
            var saved = currentContext;
            try {
              currentContext = null;
              return callback.apply(thisArg, args);
            } finally {
              currentContext = saved;
            }
          } else {
            return callback.apply(thisArg, args);
          }
        };
        return Slot2;
      }();
    };
    globalKey = "@wry/context:Slot";
    host = Array;
    Slot = host[globalKey] || function() {
      var Slot2 = makeSlotClass();
      try {
        Object.defineProperty(host, globalKey, {
          value: host[globalKey] = Slot2,
          enumerable: false,
          writable: false,
          configurable: false
        });
      } finally {
        return Slot2;
      }
    }();
    bind = Slot.bind;
    noContext = Slot.noContext;
  }
});

// ../../node_modules/optimism/lib/bundle.esm.js
function defaultDispose() {
}
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a, b) {
  var len = a.length;
  return len > 0 && len === b.length && a[len - 1] === b[len - 1];
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
function rememberParent(child) {
  var parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry) {
  var originalChildren = forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);
  if (maybeSubscribe(entry)) {
    setClean(entry);
  }
  originalChildren.forEach(maybeReportOrphan);
  return valueGet(entry.value);
}
function recomputeNewValue(entry) {
  entry.recomputing = true;
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, entry.args);
  } catch (e) {
    entry.value[1] = e;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  child.parents.forEach(function(parent) {
    return reportDirtyChild(parent, child);
  });
}
function reportClean(child) {
  child.parents.forEach(function(parent) {
    return reportCleanChild(parent, child);
  });
}
function reportDirtyChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  reportDirty(parent);
}
function reportCleanChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  var childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  var dc = parent.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      parent.dirtyChildren = null;
    }
  }
}
function maybeReportOrphan(entry) {
  return entry.parents.size === 0 && typeof entry.reportOrphan === "function" && entry.reportOrphan() === true;
}
function forgetChildren(parent) {
  var children = reusableEmptyArray;
  if (parent.childValues.size > 0) {
    children = [];
    parent.childValues.forEach(function(_value, child) {
      forgetChild(parent, child);
      children.push(child);
    });
  }
  assert(parent.dirtyChildren === null);
  return children;
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, entry.args);
    } catch (e) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
function maybeUnsubscribe(entry) {
  var unsubscribe = entry.unsubscribe;
  if (typeof unsubscribe === "function") {
    entry.unsubscribe = void 0;
    unsubscribe();
  }
}
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
function defaultMakeCacheKey() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return keyTrie.lookupArray(args);
}
function wrap2(originalFunction, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  var cache = new Cache2(options.max || Math.pow(2, 16), function(entry) {
    return entry.dispose();
  });
  var disposable = !!options.disposable;
  var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;
  function optimistic() {
    if (disposable && !parentEntrySlot.hasValue()) {
      return void 0;
    }
    var key = makeCacheKey.apply(null, arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    var args = Array.prototype.slice.call(arguments);
    var entry = cache.get(key);
    if (entry) {
      entry.args = args;
    } else {
      entry = new Entry(originalFunction, args);
      cache.set(key, entry);
      entry.subscribe = options.subscribe;
      if (disposable) {
        entry.reportOrphan = function() {
          return cache.delete(key);
        };
      }
    }
    var value = entry.recompute();
    cache.set(key, entry);
    caches.add(cache);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach(function(cache2) {
        return cache2.clean();
      });
      caches.clear();
    }
    return disposable ? void 0 : value;
  }
  optimistic.dirty = function() {
    var key = makeCacheKey.apply(null, arguments);
    var child = key !== void 0 && cache.get(key);
    if (child) {
      child.setDirty();
    }
  };
  return optimistic;
}
var Cache2, parentEntrySlot, reusableEmptyArray, emptySetPool, POOL_TARGET_SIZE, Entry, KeyTrie, keyTrie, caches;
var init_bundle_esm7 = __esm({
  "../../node_modules/optimism/lib/bundle.esm.js"() {
    init_context_esm();
    init_context_esm();
    Cache2 = function() {
      function Cache3(max, dispose) {
        if (max === void 0) {
          max = Infinity;
        }
        if (dispose === void 0) {
          dispose = defaultDispose;
        }
        this.max = max;
        this.dispose = dispose;
        this.map = /* @__PURE__ */ new Map();
        this.newest = null;
        this.oldest = null;
      }
      Cache3.prototype.has = function(key) {
        return this.map.has(key);
      };
      Cache3.prototype.get = function(key) {
        var entry = this.getEntry(key);
        return entry && entry.value;
      };
      Cache3.prototype.getEntry = function(key) {
        var entry = this.map.get(key);
        if (entry && entry !== this.newest) {
          var older = entry.older, newer = entry.newer;
          if (newer) {
            newer.older = older;
          }
          if (older) {
            older.newer = newer;
          }
          entry.older = this.newest;
          entry.older.newer = entry;
          entry.newer = null;
          this.newest = entry;
          if (entry === this.oldest) {
            this.oldest = newer;
          }
        }
        return entry;
      };
      Cache3.prototype.set = function(key, value) {
        var entry = this.getEntry(key);
        if (entry) {
          return entry.value = value;
        }
        entry = {
          key,
          value,
          newer: null,
          older: this.newest
        };
        if (this.newest) {
          this.newest.newer = entry;
        }
        this.newest = entry;
        this.oldest = this.oldest || entry;
        this.map.set(key, entry);
        return entry.value;
      };
      Cache3.prototype.clean = function() {
        while (this.oldest && this.map.size > this.max) {
          this.delete(this.oldest.key);
        }
      };
      Cache3.prototype.delete = function(key) {
        var entry = this.map.get(key);
        if (entry) {
          if (entry === this.newest) {
            this.newest = entry.older;
          }
          if (entry === this.oldest) {
            this.oldest = entry.newer;
          }
          if (entry.newer) {
            entry.newer.older = entry.older;
          }
          if (entry.older) {
            entry.older.newer = entry.newer;
          }
          this.map.delete(key);
          this.dispose(entry.value, key);
          return true;
        }
        return false;
      };
      return Cache3;
    }();
    parentEntrySlot = new Slot();
    reusableEmptyArray = [];
    emptySetPool = [];
    POOL_TARGET_SIZE = 100;
    Entry = function() {
      function Entry2(fn, args) {
        this.fn = fn;
        this.args = args;
        this.parents = /* @__PURE__ */ new Set();
        this.childValues = /* @__PURE__ */ new Map();
        this.dirtyChildren = null;
        this.dirty = true;
        this.recomputing = false;
        this.value = [];
        ++Entry2.count;
      }
      Entry2.prototype.recompute = function() {
        assert(!this.recomputing, "already recomputing");
        if (!rememberParent(this) && maybeReportOrphan(this)) {
          return void 0;
        }
        return mightBeDirty(this) ? reallyRecompute(this) : valueGet(this.value);
      };
      Entry2.prototype.setDirty = function() {
        if (this.dirty)
          return;
        this.dirty = true;
        this.value.length = 0;
        reportDirty(this);
        maybeUnsubscribe(this);
      };
      Entry2.prototype.dispose = function() {
        var _this = this;
        forgetChildren(this).forEach(maybeReportOrphan);
        maybeUnsubscribe(this);
        this.parents.forEach(function(parent) {
          parent.setDirty();
          forgetChild(parent, _this);
        });
      };
      Entry2.count = 0;
      return Entry2;
    }();
    KeyTrie = function() {
      function KeyTrie2(weakness) {
        this.weakness = weakness;
      }
      KeyTrie2.prototype.lookup = function() {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          array[_i] = arguments[_i];
        }
        return this.lookupArray(array);
      };
      KeyTrie2.prototype.lookupArray = function(array) {
        var node = this;
        array.forEach(function(key) {
          return node = node.getChildTrie(key);
        });
        return node.data || (node.data = /* @__PURE__ */ Object.create(null));
      };
      KeyTrie2.prototype.getChildTrie = function(key) {
        var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
        var child = map.get(key);
        if (!child)
          map.set(key, child = new KeyTrie2(this.weakness));
        return child;
      };
      return KeyTrie2;
    }();
    keyTrie = new KeyTrie(typeof WeakMap === "function");
    caches = /* @__PURE__ */ new Set();
  }
});

// ../../node_modules/apollo-cache-inmemory/lib/bundle.esm.js
var bundle_esm_exports4 = {};
__export(bundle_esm_exports4, {
  HeuristicFragmentMatcher: () => HeuristicFragmentMatcher,
  InMemoryCache: () => InMemoryCache,
  IntrospectionFragmentMatcher: () => IntrospectionFragmentMatcher,
  ObjectCache: () => ObjectCache,
  StoreReader: () => StoreReader,
  StoreWriter: () => StoreWriter,
  WriteError: () => WriteError,
  assertIdValue: () => assertIdValue,
  defaultDataIdFromObject: () => defaultDataIdFromObject,
  defaultNormalizedCacheFactory: () => defaultNormalizedCacheFactory$1,
  enhanceErrorWithDocument: () => enhanceErrorWithDocument
});
function shouldWarn() {
  var answer = !haveWarned;
  if (!isTest()) {
    haveWarned = true;
  }
  return answer;
}
function defaultNormalizedCacheFactory(seed) {
  return new DepTrackingCache(seed);
}
function assertSelectionSetForIdValue(field, value) {
  if (!field.selectionSet && isIdValue(value)) {
    throw false ? new InvariantError(10) : new InvariantError("Missing selection set for object of type " + value.typename + " returned for query field " + field.name.value);
  }
}
function defaultFragmentMatcher() {
  return true;
}
function assertIdValue(idValue) {
  false ? invariant(isIdValue(idValue), 11) : invariant(isIdValue(idValue), "Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.");
}
function readStoreResolver(object, typename, fieldName, args, context, _a) {
  var resultKey = _a.resultKey, directives = _a.directives;
  var storeKeyName = fieldName;
  if (args || directives) {
    storeKeyName = getStoreKeyName(storeKeyName, args, directives);
  }
  var fieldValue = void 0;
  if (object) {
    fieldValue = object[storeKeyName];
    if (typeof fieldValue === "undefined" && context.cacheRedirects && typeof typename === "string") {
      var type = context.cacheRedirects[typename];
      if (type) {
        var resolver = type[fieldName];
        if (resolver) {
          fieldValue = resolver(object, args, {
            getCacheKey: function(storeObj) {
              var id = context.dataIdFromObject(storeObj);
              return id && toIdValue({
                id,
                typename: storeObj.__typename
              });
            }
          });
        }
      }
    }
  }
  if (typeof fieldValue === "undefined") {
    return {
      result: fieldValue,
      missing: [{
        object,
        fieldName: storeKeyName,
        tolerable: false
      }]
    };
  }
  if (isJsonValue(fieldValue)) {
    fieldValue = fieldValue.json;
  }
  return {
    result: fieldValue
  };
}
function defaultNormalizedCacheFactory$1(seed) {
  return new ObjectCache(seed);
}
function enhanceErrorWithDocument(error, document) {
  var enhancedError = new WriteError("Error writing result to store for query:\n " + JSON.stringify(document));
  enhancedError.message += "\n" + error.message;
  enhancedError.stack = error.stack;
  return enhancedError;
}
function isGeneratedId(id) {
  return id[0] === "$";
}
function mergeWithGenerated(generatedKey, realKey, cache) {
  if (generatedKey === realKey) {
    return false;
  }
  var generated = cache.get(generatedKey);
  var real = cache.get(realKey);
  var madeChanges = false;
  Object.keys(generated).forEach(function(key) {
    var value = generated[key];
    var realValue = real[key];
    if (isIdValue(value) && isGeneratedId(value.id) && isIdValue(realValue) && !equal(value, realValue) && mergeWithGenerated(value.id, realValue.id, cache)) {
      madeChanges = true;
    }
  });
  cache.delete(generatedKey);
  var newRealValue = __assign3(__assign3({}, generated), real);
  if (equal(newRealValue, real)) {
    return madeChanges;
  }
  cache.set(realKey, newRealValue);
  return true;
}
function isDataProcessed(dataId, field, processedData) {
  if (!processedData) {
    return false;
  }
  if (processedData[dataId]) {
    if (processedData[dataId].indexOf(field) >= 0) {
      return true;
    } else {
      processedData[dataId].push(field);
    }
  } else {
    processedData[dataId] = [field];
  }
  return false;
}
function defaultDataIdFromObject(result) {
  if (result.__typename) {
    if (result.id !== void 0) {
      return result.__typename + ":" + result.id;
    }
    if (result._id !== void 0) {
      return result.__typename + ":" + result._id;
    }
  }
  return null;
}
var haveWarned, HeuristicFragmentMatcher, IntrospectionFragmentMatcher, hasOwn, DepTrackingCache, StoreReader, ObjectCache, WriteError, StoreWriter, defaultConfig, hasOwn$1, OptimisticCacheLayer, InMemoryCache;
var init_bundle_esm8 = __esm({
  "../../node_modules/apollo-cache-inmemory/lib/bundle.esm.js"() {
    init_tslib_es63();
    init_bundle_esm6();
    init_bundle_esm();
    init_bundle_esm7();
    init_invariant_esm();
    haveWarned = false;
    HeuristicFragmentMatcher = function() {
      function HeuristicFragmentMatcher2() {
      }
      HeuristicFragmentMatcher2.prototype.ensureReady = function() {
        return Promise.resolve();
      };
      HeuristicFragmentMatcher2.prototype.canBypassInit = function() {
        return true;
      };
      HeuristicFragmentMatcher2.prototype.match = function(idValue, typeCondition, context) {
        var obj = context.store.get(idValue.id);
        var isRootQuery = idValue.id === "ROOT_QUERY";
        if (!obj) {
          return isRootQuery;
        }
        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && "Query" : _a;
        if (!__typename) {
          if (shouldWarn()) {
            invariant.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
            invariant.warn("Could not find __typename on Fragment ", typeCondition, obj);
            invariant.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
          }
          return "heuristic";
        }
        if (__typename === typeCondition) {
          return true;
        }
        if (shouldWarn()) {
          invariant.error("You are using the simple (heuristic) fragment matcher, but your queries contain union or interface types. Apollo Client will not be able to accurately map fragments. To make this error go away, use the `IntrospectionFragmentMatcher` as described in the docs: https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher");
        }
        return "heuristic";
      };
      return HeuristicFragmentMatcher2;
    }();
    IntrospectionFragmentMatcher = function() {
      function IntrospectionFragmentMatcher2(options) {
        if (options && options.introspectionQueryResultData) {
          this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);
          this.isReady = true;
        } else {
          this.isReady = false;
        }
        this.match = this.match.bind(this);
      }
      IntrospectionFragmentMatcher2.prototype.match = function(idValue, typeCondition, context) {
        false ? invariant(this.isReady, 1) : invariant(this.isReady, "FragmentMatcher.match() was called before FragmentMatcher.init()");
        var obj = context.store.get(idValue.id);
        var isRootQuery = idValue.id === "ROOT_QUERY";
        if (!obj) {
          return isRootQuery;
        }
        var _a = obj.__typename, __typename = _a === void 0 ? isRootQuery && "Query" : _a;
        false ? invariant(__typename, 2) : invariant(__typename, "Cannot match fragment because __typename property is missing: " + JSON.stringify(obj));
        if (__typename === typeCondition) {
          return true;
        }
        var implementingTypes = this.possibleTypesMap[typeCondition];
        if (__typename && implementingTypes && implementingTypes.indexOf(__typename) > -1) {
          return true;
        }
        return false;
      };
      IntrospectionFragmentMatcher2.prototype.parseIntrospectionResult = function(introspectionResultData) {
        var typeMap = {};
        introspectionResultData.__schema.types.forEach(function(type) {
          if (type.kind === "UNION" || type.kind === "INTERFACE") {
            typeMap[type.name] = type.possibleTypes.map(function(implementingType) {
              return implementingType.name;
            });
          }
        });
        return typeMap;
      };
      return IntrospectionFragmentMatcher2;
    }();
    hasOwn = Object.prototype.hasOwnProperty;
    DepTrackingCache = function() {
      function DepTrackingCache2(data) {
        var _this = this;
        if (data === void 0) {
          data = /* @__PURE__ */ Object.create(null);
        }
        this.data = data;
        this.depend = wrap2(function(dataId) {
          return _this.data[dataId];
        }, {
          disposable: true,
          makeCacheKey: function(dataId) {
            return dataId;
          }
        });
      }
      DepTrackingCache2.prototype.toObject = function() {
        return this.data;
      };
      DepTrackingCache2.prototype.get = function(dataId) {
        this.depend(dataId);
        return this.data[dataId];
      };
      DepTrackingCache2.prototype.set = function(dataId, value) {
        var oldValue = this.data[dataId];
        if (value !== oldValue) {
          this.data[dataId] = value;
          this.depend.dirty(dataId);
        }
      };
      DepTrackingCache2.prototype.delete = function(dataId) {
        if (hasOwn.call(this.data, dataId)) {
          delete this.data[dataId];
          this.depend.dirty(dataId);
        }
      };
      DepTrackingCache2.prototype.clear = function() {
        this.replace(null);
      };
      DepTrackingCache2.prototype.replace = function(newData) {
        var _this = this;
        if (newData) {
          Object.keys(newData).forEach(function(dataId) {
            _this.set(dataId, newData[dataId]);
          });
          Object.keys(this.data).forEach(function(dataId) {
            if (!hasOwn.call(newData, dataId)) {
              _this.delete(dataId);
            }
          });
        } else {
          Object.keys(this.data).forEach(function(dataId) {
            _this.delete(dataId);
          });
        }
      };
      return DepTrackingCache2;
    }();
    StoreReader = function() {
      function StoreReader2(_a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, _c = _b.cacheKeyRoot, cacheKeyRoot = _c === void 0 ? new KeyTrie(canUseWeakMap) : _c, _d = _b.freezeResults, freezeResults = _d === void 0 ? false : _d;
        var _e = this, executeStoreQuery = _e.executeStoreQuery, executeSelectionSet = _e.executeSelectionSet, executeSubSelectedArray = _e.executeSubSelectedArray;
        this.freezeResults = freezeResults;
        this.executeStoreQuery = wrap2(function(options) {
          return executeStoreQuery.call(_this, options);
        }, {
          makeCacheKey: function(_a2) {
            var query = _a2.query, rootValue = _a2.rootValue, contextValue = _a2.contextValue, variableValues = _a2.variableValues, fragmentMatcher = _a2.fragmentMatcher;
            if (contextValue.store instanceof DepTrackingCache) {
              return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
            }
          }
        });
        this.executeSelectionSet = wrap2(function(options) {
          return executeSelectionSet.call(_this, options);
        }, {
          makeCacheKey: function(_a2) {
            var selectionSet = _a2.selectionSet, rootValue = _a2.rootValue, execContext = _a2.execContext;
            if (execContext.contextValue.store instanceof DepTrackingCache) {
              return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
            }
          }
        });
        this.executeSubSelectedArray = wrap2(function(options) {
          return executeSubSelectedArray.call(_this, options);
        }, {
          makeCacheKey: function(_a2) {
            var field = _a2.field, array = _a2.array, execContext = _a2.execContext;
            if (execContext.contextValue.store instanceof DepTrackingCache) {
              return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));
            }
          }
        });
      }
      StoreReader2.prototype.readQueryFromStore = function(options) {
        return this.diffQueryAgainstStore(__assign3(__assign3({}, options), { returnPartialData: false })).result;
      };
      StoreReader2.prototype.diffQueryAgainstStore = function(_a) {
        var store = _a.store, query = _a.query, variables = _a.variables, previousResult = _a.previousResult, _b = _a.returnPartialData, returnPartialData = _b === void 0 ? true : _b, _c = _a.rootId, rootId = _c === void 0 ? "ROOT_QUERY" : _c, fragmentMatcherFunction = _a.fragmentMatcherFunction, config = _a.config;
        var queryDefinition = getQueryDefinition(query);
        variables = assign({}, getDefaultValues(queryDefinition), variables);
        var context = {
          store,
          dataIdFromObject: config && config.dataIdFromObject,
          cacheRedirects: config && config.cacheRedirects || {}
        };
        var execResult = this.executeStoreQuery({
          query,
          rootValue: {
            type: "id",
            id: rootId,
            generated: true,
            typename: "Query"
          },
          contextValue: context,
          variableValues: variables,
          fragmentMatcher: fragmentMatcherFunction
        });
        var hasMissingFields = execResult.missing && execResult.missing.length > 0;
        if (hasMissingFields && !returnPartialData) {
          execResult.missing.forEach(function(info) {
            if (info.tolerable)
              return;
            throw false ? new InvariantError(8) : new InvariantError("Can't find field " + info.fieldName + " on object " + JSON.stringify(info.object, null, 2) + ".");
          });
        }
        if (previousResult) {
          if (equal(previousResult, execResult.result)) {
            execResult.result = previousResult;
          }
        }
        return {
          result: execResult.result,
          complete: !hasMissingFields
        };
      };
      StoreReader2.prototype.executeStoreQuery = function(_a) {
        var query = _a.query, rootValue = _a.rootValue, contextValue = _a.contextValue, variableValues = _a.variableValues, _b = _a.fragmentMatcher, fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
        var mainDefinition = getMainDefinition(query);
        var fragments = getFragmentDefinitions(query);
        var fragmentMap = createFragmentMap(fragments);
        var execContext = {
          query,
          fragmentMap,
          contextValue,
          variableValues,
          fragmentMatcher
        };
        return this.executeSelectionSet({
          selectionSet: mainDefinition.selectionSet,
          rootValue,
          execContext
        });
      };
      StoreReader2.prototype.executeSelectionSet = function(_a) {
        var _this = this;
        var selectionSet = _a.selectionSet, rootValue = _a.rootValue, execContext = _a.execContext;
        var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;
        var finalResult = { result: null };
        var objectsToMerge = [];
        var object = contextValue.store.get(rootValue.id);
        var typename = object && object.__typename || rootValue.id === "ROOT_QUERY" && "Query" || void 0;
        function handleMissing(result) {
          var _a2;
          if (result.missing) {
            finalResult.missing = finalResult.missing || [];
            (_a2 = finalResult.missing).push.apply(_a2, result.missing);
          }
          return result.result;
        }
        selectionSet.selections.forEach(function(selection) {
          var _a2;
          if (!shouldInclude(selection, variables)) {
            return;
          }
          if (isField(selection)) {
            var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));
            if (typeof fieldResult !== "undefined") {
              objectsToMerge.push((_a2 = {}, _a2[resultKeyNameFromField(selection)] = fieldResult, _a2));
            }
          } else {
            var fragment = void 0;
            if (isInlineFragment(selection)) {
              fragment = selection;
            } else {
              fragment = fragmentMap[selection.name.value];
              if (!fragment) {
                throw false ? new InvariantError(9) : new InvariantError("No fragment named " + selection.name.value);
              }
            }
            var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;
            var match = !typeCondition || execContext.fragmentMatcher(rootValue, typeCondition, contextValue);
            if (match) {
              var fragmentExecResult = _this.executeSelectionSet({
                selectionSet: fragment.selectionSet,
                rootValue,
                execContext
              });
              if (match === "heuristic" && fragmentExecResult.missing) {
                fragmentExecResult = __assign3(__assign3({}, fragmentExecResult), { missing: fragmentExecResult.missing.map(function(info) {
                  return __assign3(__assign3({}, info), { tolerable: true });
                }) });
              }
              objectsToMerge.push(handleMissing(fragmentExecResult));
            }
          }
        });
        finalResult.result = mergeDeepArray(objectsToMerge);
        if (this.freezeResults && true) {
          Object.freeze(finalResult.result);
        }
        return finalResult;
      };
      StoreReader2.prototype.executeField = function(object, typename, field, execContext) {
        var variables = execContext.variableValues, contextValue = execContext.contextValue;
        var fieldName = field.name.value;
        var args = argumentsObjectFromField(field, variables);
        var info = {
          resultKey: resultKeyNameFromField(field),
          directives: getDirectiveInfoFromField(field, variables)
        };
        var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);
        if (Array.isArray(readStoreResult.result)) {
          return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({
            field,
            array: readStoreResult.result,
            execContext
          }));
        }
        if (!field.selectionSet) {
          assertSelectionSetForIdValue(field, readStoreResult.result);
          if (this.freezeResults && true) {
            maybeDeepFreeze(readStoreResult);
          }
          return readStoreResult;
        }
        if (readStoreResult.result == null) {
          return readStoreResult;
        }
        return this.combineExecResults(readStoreResult, this.executeSelectionSet({
          selectionSet: field.selectionSet,
          rootValue: readStoreResult.result,
          execContext
        }));
      };
      StoreReader2.prototype.combineExecResults = function() {
        var execResults = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          execResults[_i] = arguments[_i];
        }
        var missing;
        execResults.forEach(function(execResult) {
          if (execResult.missing) {
            missing = missing || [];
            missing.push.apply(missing, execResult.missing);
          }
        });
        return {
          result: execResults.pop().result,
          missing
        };
      };
      StoreReader2.prototype.executeSubSelectedArray = function(_a) {
        var _this = this;
        var field = _a.field, array = _a.array, execContext = _a.execContext;
        var missing;
        function handleMissing(childResult) {
          if (childResult.missing) {
            missing = missing || [];
            missing.push.apply(missing, childResult.missing);
          }
          return childResult.result;
        }
        array = array.map(function(item) {
          if (item === null) {
            return null;
          }
          if (Array.isArray(item)) {
            return handleMissing(_this.executeSubSelectedArray({
              field,
              array: item,
              execContext
            }));
          }
          if (field.selectionSet) {
            return handleMissing(_this.executeSelectionSet({
              selectionSet: field.selectionSet,
              rootValue: item,
              execContext
            }));
          }
          assertSelectionSetForIdValue(field, item);
          return item;
        });
        if (this.freezeResults && true) {
          Object.freeze(array);
        }
        return { result: array, missing };
      };
      return StoreReader2;
    }();
    ObjectCache = function() {
      function ObjectCache2(data) {
        if (data === void 0) {
          data = /* @__PURE__ */ Object.create(null);
        }
        this.data = data;
      }
      ObjectCache2.prototype.toObject = function() {
        return this.data;
      };
      ObjectCache2.prototype.get = function(dataId) {
        return this.data[dataId];
      };
      ObjectCache2.prototype.set = function(dataId, value) {
        this.data[dataId] = value;
      };
      ObjectCache2.prototype.delete = function(dataId) {
        this.data[dataId] = void 0;
      };
      ObjectCache2.prototype.clear = function() {
        this.data = /* @__PURE__ */ Object.create(null);
      };
      ObjectCache2.prototype.replace = function(newData) {
        this.data = newData || /* @__PURE__ */ Object.create(null);
      };
      return ObjectCache2;
    }();
    WriteError = function(_super) {
      __extends2(WriteError2, _super);
      function WriteError2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "WriteError";
        return _this;
      }
      return WriteError2;
    }(Error);
    StoreWriter = function() {
      function StoreWriter2() {
      }
      StoreWriter2.prototype.writeQueryToStore = function(_a) {
        var query = _a.query, result = _a.result, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
        return this.writeResultToStore({
          dataId: "ROOT_QUERY",
          result,
          document: query,
          store,
          variables,
          dataIdFromObject,
          fragmentMatcherFunction
        });
      };
      StoreWriter2.prototype.writeResultToStore = function(_a) {
        var dataId = _a.dataId, result = _a.result, document = _a.document, _b = _a.store, store = _b === void 0 ? defaultNormalizedCacheFactory() : _b, variables = _a.variables, dataIdFromObject = _a.dataIdFromObject, fragmentMatcherFunction = _a.fragmentMatcherFunction;
        var operationDefinition = getOperationDefinition(document);
        try {
          return this.writeSelectionSetToStore({
            result,
            dataId,
            selectionSet: operationDefinition.selectionSet,
            context: {
              store,
              processedData: {},
              variables: assign({}, getDefaultValues(operationDefinition), variables),
              dataIdFromObject,
              fragmentMap: createFragmentMap(getFragmentDefinitions(document)),
              fragmentMatcherFunction
            }
          });
        } catch (e) {
          throw enhanceErrorWithDocument(e, document);
        }
      };
      StoreWriter2.prototype.writeSelectionSetToStore = function(_a) {
        var _this = this;
        var result = _a.result, dataId = _a.dataId, selectionSet = _a.selectionSet, context = _a.context;
        var variables = context.variables, store = context.store, fragmentMap = context.fragmentMap;
        selectionSet.selections.forEach(function(selection) {
          var _a2;
          if (!shouldInclude(selection, variables)) {
            return;
          }
          if (isField(selection)) {
            var resultFieldKey = resultKeyNameFromField(selection);
            var value = result[resultFieldKey];
            if (typeof value !== "undefined") {
              _this.writeFieldToStore({
                dataId,
                value,
                field: selection,
                context
              });
            } else {
              var isDefered = false;
              var isClient = false;
              if (selection.directives && selection.directives.length) {
                isDefered = selection.directives.some(function(directive) {
                  return directive.name && directive.name.value === "defer";
                });
                isClient = selection.directives.some(function(directive) {
                  return directive.name && directive.name.value === "client";
                });
              }
              if (!isDefered && !isClient && context.fragmentMatcherFunction) {
                invariant.warn("Missing field " + resultFieldKey + " in " + JSON.stringify(result, null, 2).substring(0, 100));
              }
            }
          } else {
            var fragment = void 0;
            if (isInlineFragment(selection)) {
              fragment = selection;
            } else {
              fragment = (fragmentMap || {})[selection.name.value];
              false ? invariant(fragment, 3) : invariant(fragment, "No fragment named " + selection.name.value + ".");
            }
            var matches = true;
            if (context.fragmentMatcherFunction && fragment.typeCondition) {
              var id = dataId || "self";
              var idValue = toIdValue({ id, typename: void 0 });
              var fakeContext = {
                store: new ObjectCache((_a2 = {}, _a2[id] = result, _a2)),
                cacheRedirects: {}
              };
              var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);
              if (!isProduction() && match === "heuristic") {
                invariant.error("WARNING: heuristic fragment matching going on!");
              }
              matches = !!match;
            }
            if (matches) {
              _this.writeSelectionSetToStore({
                result,
                selectionSet: fragment.selectionSet,
                dataId,
                context
              });
            }
          }
        });
        return store;
      };
      StoreWriter2.prototype.writeFieldToStore = function(_a) {
        var _b;
        var field = _a.field, value = _a.value, dataId = _a.dataId, context = _a.context;
        var variables = context.variables, dataIdFromObject = context.dataIdFromObject, store = context.store;
        var storeValue;
        var storeObject;
        var storeFieldName = storeKeyNameFromField(field, variables);
        if (!field.selectionSet || value === null) {
          storeValue = value != null && typeof value === "object" ? { type: "json", json: value } : value;
        } else if (Array.isArray(value)) {
          var generatedId = dataId + "." + storeFieldName;
          storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
        } else {
          var valueDataId = dataId + "." + storeFieldName;
          var generated = true;
          if (!isGeneratedId(valueDataId)) {
            valueDataId = "$" + valueDataId;
          }
          if (dataIdFromObject) {
            var semanticId = dataIdFromObject(value);
            false ? invariant(!semanticId || !isGeneratedId(semanticId), 4) : invariant(!semanticId || !isGeneratedId(semanticId), 'IDs returned by dataIdFromObject cannot begin with the "$" character.');
            if (semanticId || typeof semanticId === "number" && semanticId === 0) {
              valueDataId = semanticId;
              generated = false;
            }
          }
          if (!isDataProcessed(valueDataId, field, context.processedData)) {
            this.writeSelectionSetToStore({
              dataId: valueDataId,
              result: value,
              selectionSet: field.selectionSet,
              context
            });
          }
          var typename = value.__typename;
          storeValue = toIdValue({ id: valueDataId, typename }, generated);
          storeObject = store.get(dataId);
          var escapedId = storeObject && storeObject[storeFieldName];
          if (escapedId !== storeValue && isIdValue(escapedId)) {
            var hadTypename = escapedId.typename !== void 0;
            var hasTypename = typename !== void 0;
            var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;
            false ? invariant(!generated || escapedId.generated || typenameChanged, 5) : invariant(!generated || escapedId.generated || typenameChanged, "Store error: the application attempted to write an object with no provided id but the store already contains an id of " + escapedId.id + " for this object. The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
            false ? invariant(!hadTypename || hasTypename, 6) : invariant(!hadTypename || hasTypename, "Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of " + escapedId.typename + " for the object of id " + escapedId.id + ". The selectionSet that was trying to be written is:\n" + JSON.stringify(field));
            if (escapedId.generated) {
              if (typenameChanged) {
                if (!generated) {
                  store.delete(escapedId.id);
                }
              } else {
                mergeWithGenerated(escapedId.id, storeValue.id, store);
              }
            }
          }
        }
        storeObject = store.get(dataId);
        if (!storeObject || !equal(storeValue, storeObject[storeFieldName])) {
          store.set(dataId, __assign3(__assign3({}, storeObject), (_b = {}, _b[storeFieldName] = storeValue, _b)));
        }
      };
      StoreWriter2.prototype.processArrayValue = function(value, generatedId, selectionSet, context) {
        var _this = this;
        return value.map(function(item, index) {
          if (item === null) {
            return null;
          }
          var itemDataId = generatedId + "." + index;
          if (Array.isArray(item)) {
            return _this.processArrayValue(item, itemDataId, selectionSet, context);
          }
          var generated = true;
          if (context.dataIdFromObject) {
            var semanticId = context.dataIdFromObject(item);
            if (semanticId) {
              itemDataId = semanticId;
              generated = false;
            }
          }
          if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
            _this.writeSelectionSetToStore({
              dataId: itemDataId,
              result: item,
              selectionSet,
              context
            });
          }
          return toIdValue({ id: itemDataId, typename: item.__typename }, generated);
        });
      };
      return StoreWriter2;
    }();
    defaultConfig = {
      fragmentMatcher: new HeuristicFragmentMatcher(),
      dataIdFromObject: defaultDataIdFromObject,
      addTypename: true,
      resultCaching: true,
      freezeResults: false
    };
    hasOwn$1 = Object.prototype.hasOwnProperty;
    OptimisticCacheLayer = function(_super) {
      __extends2(OptimisticCacheLayer2, _super);
      function OptimisticCacheLayer2(optimisticId, parent, transaction) {
        var _this = _super.call(this, /* @__PURE__ */ Object.create(null)) || this;
        _this.optimisticId = optimisticId;
        _this.parent = parent;
        _this.transaction = transaction;
        return _this;
      }
      OptimisticCacheLayer2.prototype.toObject = function() {
        return __assign3(__assign3({}, this.parent.toObject()), this.data);
      };
      OptimisticCacheLayer2.prototype.get = function(dataId) {
        return hasOwn$1.call(this.data, dataId) ? this.data[dataId] : this.parent.get(dataId);
      };
      return OptimisticCacheLayer2;
    }(ObjectCache);
    InMemoryCache = function(_super) {
      __extends2(InMemoryCache2, _super);
      function InMemoryCache2(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = _super.call(this) || this;
        _this.watches = /* @__PURE__ */ new Set();
        _this.typenameDocumentCache = /* @__PURE__ */ new Map();
        _this.cacheKeyRoot = new KeyTrie(canUseWeakMap);
        _this.silenceBroadcast = false;
        _this.config = __assign3(__assign3({}, defaultConfig), config);
        if (_this.config.customResolvers) {
          invariant.warn("customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.");
          _this.config.cacheRedirects = _this.config.customResolvers;
        }
        if (_this.config.cacheResolvers) {
          invariant.warn("cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.");
          _this.config.cacheRedirects = _this.config.cacheResolvers;
        }
        _this.addTypename = !!_this.config.addTypename;
        _this.data = _this.config.resultCaching ? new DepTrackingCache() : new ObjectCache();
        _this.optimisticData = _this.data;
        _this.storeWriter = new StoreWriter();
        _this.storeReader = new StoreReader({
          cacheKeyRoot: _this.cacheKeyRoot,
          freezeResults: config.freezeResults
        });
        var cache = _this;
        var maybeBroadcastWatch = cache.maybeBroadcastWatch;
        _this.maybeBroadcastWatch = wrap2(function(c) {
          return maybeBroadcastWatch.call(_this, c);
        }, {
          makeCacheKey: function(c) {
            if (c.optimistic) {
              return;
            }
            if (c.previousResult) {
              return;
            }
            if (cache.data instanceof DepTrackingCache) {
              return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
            }
          }
        });
        return _this;
      }
      InMemoryCache2.prototype.restore = function(data) {
        if (data)
          this.data.replace(data);
        return this;
      };
      InMemoryCache2.prototype.extract = function(optimistic) {
        if (optimistic === void 0) {
          optimistic = false;
        }
        return (optimistic ? this.optimisticData : this.data).toObject();
      };
      InMemoryCache2.prototype.read = function(options) {
        if (typeof options.rootId === "string" && typeof this.data.get(options.rootId) === "undefined") {
          return null;
        }
        var fragmentMatcher = this.config.fragmentMatcher;
        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
        return this.storeReader.readQueryFromStore({
          store: options.optimistic ? this.optimisticData : this.data,
          query: this.transformDocument(options.query),
          variables: options.variables,
          rootId: options.rootId,
          fragmentMatcherFunction,
          previousResult: options.previousResult,
          config: this.config
        }) || null;
      };
      InMemoryCache2.prototype.write = function(write) {
        var fragmentMatcher = this.config.fragmentMatcher;
        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
        this.storeWriter.writeResultToStore({
          dataId: write.dataId,
          result: write.result,
          variables: write.variables,
          document: this.transformDocument(write.query),
          store: this.data,
          dataIdFromObject: this.config.dataIdFromObject,
          fragmentMatcherFunction
        });
        this.broadcastWatches();
      };
      InMemoryCache2.prototype.diff = function(query) {
        var fragmentMatcher = this.config.fragmentMatcher;
        var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
        return this.storeReader.diffQueryAgainstStore({
          store: query.optimistic ? this.optimisticData : this.data,
          query: this.transformDocument(query.query),
          variables: query.variables,
          returnPartialData: query.returnPartialData,
          previousResult: query.previousResult,
          fragmentMatcherFunction,
          config: this.config
        });
      };
      InMemoryCache2.prototype.watch = function(watch) {
        var _this = this;
        this.watches.add(watch);
        return function() {
          _this.watches.delete(watch);
        };
      };
      InMemoryCache2.prototype.evict = function(query) {
        throw false ? new InvariantError(7) : new InvariantError("eviction is not implemented on InMemory Cache");
      };
      InMemoryCache2.prototype.reset = function() {
        this.data.clear();
        this.broadcastWatches();
        return Promise.resolve();
      };
      InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
        var toReapply = [];
        var removedCount = 0;
        var layer = this.optimisticData;
        while (layer instanceof OptimisticCacheLayer) {
          if (layer.optimisticId === idToRemove) {
            ++removedCount;
          } else {
            toReapply.push(layer);
          }
          layer = layer.parent;
        }
        if (removedCount > 0) {
          this.optimisticData = layer;
          while (toReapply.length > 0) {
            var layer_1 = toReapply.pop();
            this.performTransaction(layer_1.transaction, layer_1.optimisticId);
          }
          this.broadcastWatches();
        }
      };
      InMemoryCache2.prototype.performTransaction = function(transaction, optimisticId) {
        var _a = this, data = _a.data, silenceBroadcast = _a.silenceBroadcast;
        this.silenceBroadcast = true;
        if (typeof optimisticId === "string") {
          this.data = this.optimisticData = new OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);
        }
        try {
          transaction(this);
        } finally {
          this.silenceBroadcast = silenceBroadcast;
          this.data = data;
        }
        this.broadcastWatches();
      };
      InMemoryCache2.prototype.recordOptimisticTransaction = function(transaction, id) {
        return this.performTransaction(transaction, id);
      };
      InMemoryCache2.prototype.transformDocument = function(document) {
        if (this.addTypename) {
          var result = this.typenameDocumentCache.get(document);
          if (!result) {
            result = addTypenameToDocument(document);
            this.typenameDocumentCache.set(document, result);
            this.typenameDocumentCache.set(result, result);
          }
          return result;
        }
        return document;
      };
      InMemoryCache2.prototype.broadcastWatches = function() {
        var _this = this;
        if (!this.silenceBroadcast) {
          this.watches.forEach(function(c) {
            return _this.maybeBroadcastWatch(c);
          });
        }
      };
      InMemoryCache2.prototype.maybeBroadcastWatch = function(c) {
        c.callback(this.diff({
          query: c.query,
          variables: c.variables,
          previousResult: c.previousResult && c.previousResult(),
          optimistic: c.optimistic
        }));
      };
      return InMemoryCache2;
    }(ApolloCache);
  }
});

// ../../node_modules/apollo-client-preset/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/apollo-client-preset/lib/index.js"(exports) {
    "use strict";
    var __extends3 = exports && exports.__extends || function() {
      var extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics3(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    function __export2(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2((init_bundle_esm3(), __toCommonJS(bundle_esm_exports2)));
    __export2((init_bundle_esm2(), __toCommonJS(bundle_esm_exports)));
    var apollo_link_http_1 = (init_bundle_esm5(), __toCommonJS(bundle_esm_exports3));
    exports.HttpLink = apollo_link_http_1.HttpLink;
    __export2((init_bundle_esm8(), __toCommonJS(bundle_esm_exports4)));
    var apollo_cache_inmemory_1 = (init_bundle_esm8(), __toCommonJS(bundle_esm_exports4));
    exports.InMemoryCache = apollo_cache_inmemory_1.InMemoryCache;
    var graphql_tag_1 = (init_lib(), __toCommonJS(lib_exports));
    exports.gql = graphql_tag_1.default;
    var apollo_client_1 = (init_bundle_esm3(), __toCommonJS(bundle_esm_exports2));
    var DefaultClient = function(_super) {
      __extends3(DefaultClient2, _super);
      function DefaultClient2(config) {
        if (config === void 0) {
          config = {};
        }
        var _this = this;
        if (!config.cache)
          config.cache = new apollo_cache_inmemory_1.InMemoryCache();
        if (!config.link)
          config.link = new apollo_link_http_1.HttpLink({ uri: "/graphql" });
        _this = _super.call(this, config) || this;
        return _this;
      }
      return DefaultClient2;
    }(apollo_client_1.default);
    exports.default = DefaultClient;
  }
});

// dep:apollo-client-preset
var apollo_client_preset_default = require_lib();
export {
  apollo_client_preset_default as default
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=apollo-client-preset.js.map
